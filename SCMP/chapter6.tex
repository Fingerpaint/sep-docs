\chapter{Tools, Techniques and Methods}
\label{chap:tools}
In this chapter, the various tools are discussed that are used in the \projectname{} project. Also, some methods to keep the various libraries tidy are discussed.

\section{Tools}
\label{sec:tools}
The \applicationname{} is a web application that runs locally in the browser. The client has indicated it should be implemented in HTML5. At the moment, HTML5 is a sort of ``umbrella definition'' for a lot of technologies. In practice, what we will do is implement the application in JavaScript, making heavy use of the canvas element and everything it supports. Note that currently, the canvas element supports quite a lot of features: simple things like drawing rectangles, but also drawing curves and more complex shapes (polygons) is supported. Even creating effects like blur or inverting colours belongs to the possibilities. Finally, 3D-drawing is supported. We will not make use of the latter, but the idea is clear: a canvas is the right basis to build the \applicationname{} on.

To make developing the software easier, we use a couple of frameworks. This enables us to document the code more easily and more clearly (including generating documentation from the comments in the code). Additionally, it enables automated testing. This is explained below.

\subsection{Git}
\label{subsec:tools-git}
All code and documentation is stored in Git repositories. Git is a distributed, lightweight version control system. It enables all team members to work efficiently in parallel on the same documents/code base, even to some extent on the same file. Apart from enabling working in parallel, it also provides an implicit backup system, as every team member has a local copy of a repository.

\subsection{GitHub}
\label{subsec:tools-github}
Git is a distributed system in which a central server is needed. This is the ``main'' repository, to which a number of project members can connect (this is called \emph{cloning}, every project member has a \emph{clone} of the ``main'' repository on his/her machine). GitHub is a (commercial) service that can host the ``main'' repository for us. As long as the repository is public, the service is free to use. The client has expressed that the project can be public, so we can use this free service from GitHub. Apart from providing ``simple'' hosting, GitHub also comes with a nice-looking web interface with which anyone can browse the repository. Also, there is a Wiki and bug-tracking system. Finally, GitHub provides a mechanism for hosting a website by means of creating a repository with a special name. We use this to build a website on which we can present some progress information to the client and maybe documentation or other project-related things.

\subsection{Google Web Toolkit (GWT)}
\label{subsec:tools-gwt}
The GWT\footnote{The homepage of the GWT can be found at \url{https://developers.google.com/web-toolkit/}.} is a toolkit that provides two important things for us:
\begin{itemize}
	\item possibility to develop (complex) browser-based applications productively;
	\item optimised JavaScript generated by the GWT provides the user with a high-performance end product.
\end{itemize}
A great advantage of the GWT to us is that it enables developers to create web applications without requiring the developer to be an expert in browser quirks or JavaScript. A developer simply needs to know Java (which is well-known and easy to learn) to understand the code of the application. The heart of the GWT, namely, is a compiler that can convert (GWT-enabled) Java code into JavaScript. The GWT even generates different versions of the JavaScript for the five most widely used browsers\footnote{Internet Explorer, Chrome, Firefox, Safari and Opera.}, optimising performance and preventing browser quirks from having effect on the application.

Finally, the GWT includes a plug-in for Eclipse and an extension for Chrome to profile the application, which makes developing again more productive. When using the plug-in, it is possible to deploy the web application on a local server, keeping the developing cycle very short. If a new feature is implemented, a ``production version'' of the web application can be uploaded to a server.

\subsection{Selenium}
\label{subsec:tools-selenium}
From the start of the project, we want to be able to test the software automatically. As we are developing a web application here, an important part is user experience. Of course, one of the most important facets of the user experience is the visual facet: what does it look like? However, it is very labour intensive to test this manually: that would require a tester to open the application in a number of browsers and perform the same sequence of actions in every browser. Still, probably just a subset of all available browsers will be tested. It is simply impossible to test the application in all browsers on desktop Windows, Mac and Linux machines and on mobile iOS and Android machines - which are not even \emph{all} platforms available on the market.

Selenium\footnote{The homepage of Selenium can be found at \url{http://docs.seleniumhq.org/}.} is a library that can aid here. It is available in multiple programming languages. We use the Java-variant. Selenium provides a means of creating and executing tests in a lot of browsers, including mobile browsers for iPhone and Android. A test in this context is literally a sequence of actions \emph{as the user could perform them}. It is possible to click elements, type text, submit forms, drag-and-drop, simulate clicks, et cetera.

The code base of Selenium also includes a server. This server can be used to run actual tests on a remote machine, while the program that is issuing the tests runs on a local machine. Commands/actions are sent to the server through a tunnel, the server executes those actions in a browser of choice and returns the results to the local machine, when asked for. This functionality is used by us to be able to run tests from any machine on a number of different platforms.

\subsection{Servers}
\label{subsec:tools-server}
The above described Selenium server will run on a virtual server provided by BCF. This server runs on Microsoft Windows 7. Apart from testing, we also run our application on a server. This will be a different server, that will be provided by the client. The application is deployed on a Jetty server (see section \ref{subsec:tools-jetty}), that listens on port 80, the default HTTP port. This implies that our application can be reached directly via the browser on its IP-address or on its domain name, if that is configured correctly by the client.

\subsection{Jetty}
\label{subsec:tools-jetty}
Jetty\footnote{The homepage of Jetty can be found at \url{http://www.eclipse.org/jetty/}.} is a web server and \texttt{javax.servlet} container that runs on Java. It supports web sockets, is open source and used to power the Google AppEngine. When using the Eclipse GWT plug-in, you can run develop mode, in which case a Jetty server is run locally to quickly deploy your code. Using Jetty from the range of servers available was a logical choice for us: if everything works when run locally on Jetty, it will work on another Jetty server as well (if the server on which Jetty runs is configured correctly of course).

\subsection{\LaTeX{}}
\label{subsec:tools-latex}
All documents will be generated from \LaTeX{} source files. \LaTeX{} is a tool to create professionally typeset documents. We use it for a couple of reasons. First of all, the source files are plain text. This allows us to have good version control of the source. Secondly, we like to have good-looking documents, which we can create without expert knowledge about typesetting using \LaTeX{}. Lastly, \LaTeX{} allows us to use a single file that defines the style for all documents. This ensures a consistent layout across all documents.

\section{Techniques and Methods}
In this section, we will discuss some methods we apply to keep the Git repositories tidy and the project manageable.

\subsection{Committing}
Committing changes is something that developers do a lot, so the conventions are simple, because a developer does not want to do something complex a lot. With this in mind, we have come to the following list of recommendations:

\begin{itemize}
	\item Make every relevant change to a repository a single commit. Do not combine multiple changes in a commit. This makes reverting changes easier.
	\paragraph{Example} A commit wherein both a document and the general layout are changed, is not allowed. These should be two separate commits.
	
	\item Always write a concise yet descriptive commit message for every commit. This makes it easier to read through the commit history and find relevant commits. Note that ``concise'' does not mean ``at most two sentences''. You can definitely explain in some detail what you did. Just do not repeat the code you added, because it will be visible what you changed in your commit when looking at it in detail.
	
	\item Refrain from committing binary files. These files will change a lot (probably) with every change, which does not work well in general.
\end{itemize}

\subsection{Tags and Branches}
In Git, it is possible to \emph{tag} a repository at any moment. A tag is simply a reference to the repository at a certain point in time, with a label. You can list all tags that are present in a repository and easily revert to the point in time the tag was made. GitHub even shows all tags in a drop down menu on the website, so browsing the repository at the time a tag was created is easy. We use this feature to tag the repository whenever a new version of a CI is created. The tag should then have the identifier of that CI as a label, if the CI has a label. For example: \texttt{URD-0.3}. The code in the repositories does not have an explicit identifier. When the code reaches a stable state, which should be at the end of each sprint, a tag with label \texttt{v[version]} should be created, for example \texttt{v0.1}. After each sprint, the version will be bumped with \texttt{0.1}. After the last sprint of the project, the version will be bumped to \texttt{v1.0}.

Since we have separate repositories, the above strategy will result in the following:
\begin{itemize}
	\item The repository \texttt{project-code} will only contain code, no documentation and thus only tags of the form \texttt{v[version]};
	\item The repository \texttt{project-docs} will only contain documentation and thus only tags of the form \texttt{[title abbreviation]-[version]};
	\item The repository \texttt{sep-docs} will only contain documentation and thus only tags of the form \texttt{[title abbreviation]-[version]}.
\end{itemize}